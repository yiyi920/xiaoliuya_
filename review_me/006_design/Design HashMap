Design a HashMap without using any built-in hash table libraries.

To be specific, your design should include these functions:

put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value.
get(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.
remove(key) : Remove the mapping for the value key if this map contains the mapping for the key.

Example:

MyHashMap hashMap = new MyHashMap();
hashMap.put(1, 1);          
hashMap.put(2, 2);         
hashMap.get(1);            // returns 1
hashMap.get(3);            // returns -1 (not found)
hashMap.put(2, 1);          // update the existing value
hashMap.get(2);            // returns 1 
hashMap.remove(2);          // remove the mapping for 2
hashMap.get(2);            // returns -1 (not found) 

Note:

All keys and values will be in the range of [0, 1000000].
The number of operations will be in the range of [1, 10000].
Please do not use the built-in HashMap library.

//Collisions are resolved using linked list

/*
Some of the questions which can be asked to the interviewer before implementing the solution

For simplicity, are the keys integers only?
For collision resolution, can we use chaining?
Do we have to worry about load factors?
Can we assume inputs are valid or do we have to validate them?
Can we assume this fits memory?

*/
Collisions are resolved using linked list

 class MyHashMap {
        final ListNode[] nodes = new ListNode[10000];

        public void put(int key, int value) {
            int i = idx(key);
            if (nodes[i] == null)
                nodes[i] = new ListNode(-1, -1);
            ListNode prev = find(nodes[i], key);
            if (prev.next == null)
                prev.next = new ListNode(key, value);
            else prev.next.val = value;
        }

        public int get(int key) {
            int i = idx(key);
            if (nodes[i] == null)
                return -1;
            ListNode node = find(nodes[i], key);
            return node.next == null ? -1 : node.next.val;
        }

        public void remove(int key) {
            int i = idx(key);
            if (nodes[i] == null) return;
            ListNode prev = find(nodes[i], key);
            if (prev.next == null) return;
            prev.next = prev.next.next;
        }

        int idx(int key) { return Integer.hashCode(key) % nodes.length;}

        ListNode find(ListNode bucket, int key) {
            ListNode node = bucket, prev = null;
            while (node != null && node.key != key) {
                prev = node;
                node = node.next;
            }
            return prev;
        }

        class ListNode {
            int key, val;
            ListNode next;

            ListNode(int key, int val) {
                this.key = key;
                this.val = val;
            }
        }
    }
    
    
    Solution 1: Traditional Hash-Table Implementation - Using Array of LinkedList - Accepted in 75 ms

The general implementation of HashMap uses bucket which is basically a chain of linked lists and each node 
containing <key, value> pair.
So if we have duplicate nodes, that doesn't matter - it will still replicate each key with it's value in linked list node.
When we insert the pair (10, 20) and then (10, 30), there is technically no collision involved. 
We are just replacing the old value with the new value for a given key 10, since in both cases, 10 is equal to 10 and 
also the hash code for 10 is always 10.
Collision happens when multiple keys hash to the same bucket. In that case, we need to make sure that we can distinguish 
between those keys. Chaining collision resolution is one of those techniques which is used for this.
Just for the information. In JDK 8, HashMap has been tweaked so that if keys can be compared for ordering, 
then any densely-populated bucket is implemented as a tree, so that even if there are lots of entries with 
the same hash-code, the complexity isO(log n).
Time complexity: O(1) average and O(n) worst case - for all get(),put() and remove() methods.
Space complexity: O(n) - where n is the number of entries in HashMap


Solution 2: Using Large Sized Array - Accepted in 100 ms

Time complexity: O(1) - for all get(),put() and remove() methods.
Space complexity: O(n) - where n is the maximum possible value for the key.

class MyHashMap
{
    int[] map;

    public MyHashMap()
	{
        map = new int[1000001];
        Arrays.fill(map,-1);
    }
	
    public int get(int key)
	{
        return map[key];
    }
    
	public void put(int key, int value)
	{
        map[key] = value;
    }
    
	public void remove(int key)
	{
        map[key] = -1;
    }
}
