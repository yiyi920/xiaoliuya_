/***************************************************************************************************************/
最基础的知识，细节不能出错.
/***************************************************************************************************************/
这样的input可以表示成：
Input: nums [1, 1, 1, 1, 2, 2, 2]

List<Integer> nums  ---》 nums.size()/2
int[] nums ----》 nums.length/2

如果用List<Integer>表示的， ArrayList<Integer>--》 int num = nums.get(pivot);
list可以--》private List<Integer> array = new ArrayList<Integer>();
/***************************************************************************************************************/
如何loop through hash

for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
    if (entry.getValue() > halfLen) {
        return entry.getKey();
    }
}


/***************************************************************************************************************/

int min = Integer.MAX_VALUE;
Math.min

/***************************************************************************************************************/
讲明白PriorityQueue
minHeap --》 先出来的最小 -->s升序
maxheap --》降序---》先出来最大
 PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>((Integer a,Integer b) -> b.compareTo(a));
  PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>((Integer a,Integer b) -> b - a);

PriorityQueue<Type> pq = new PriorityQueue<Type>((Type t1, Type t2)->(t1.num - t2.num));

public static void main(String[] args) {
        //这是升序 apple，PineApple，Custard Apple,
        //默认是minheap，输出顺序1->2->3
        PriorityQueue<String> pq=
                new PriorityQueue<String>(5, (a,b) -> a.compareTo(b));
        //a.compareTo(b)
        //apple -> custard-> pineApple
        
        /*
        PriorityQueue<String> pq=
                new PriorityQueue<String>(5, (a,b) -> a.length() - b.length());
        // or pq = new PriorityQueue<String>(5, Comparator.comparing(String::length));

        */
        pq.add("Apple");
        pq.add("PineApple");
        pq.add("Custard Apple");

        PriorityQueue<Integer> pq_nums=
                new PriorityQueue<Integer>(5, (a,b) -> a - b);
        PriorityQueue<Integer> pq_nums1=
                new PriorityQueue<>();
        PriorityQueue<Integer> pq_nums2=
                new PriorityQueue<Integer>(5, (a,b) -> b - a);
        pq_nums.add(1);
        pq_nums.add(2);
        pq_nums.add(3);
        pq_nums1.add(1);
        pq_nums1.add(2);
        pq_nums1.add(3);
        pq_nums2.add(1);
        pq_nums2.add(2);
        pq_nums2.add(3);

        while (pq.size() != 0)
        {
            System.out.println(pq.poll());
        }
        while (pq_nums.size() != 0)
        {
            System.out.println(pq_nums.poll());
        }
        while (pq_nums1.size() != 0)
        {
            System.out.println("---------------------");
            System.out.println(pq_nums1.poll());
        }
        while (pq_nums2.size() != 0)
        {
            System.out.println("---------------------");
            System.out.println(pq_nums2.poll());
        }
    }
    
/***************************************************************************************************************/
    How do I efficiently iterate over each entry in a Java Map?
    Map<String, String> map = ...
    for (Map.Entry<String, String> entry : map.entrySet()) {
        System.out.println(entry.getKey() + "/" + entry.getValue());
    }
    
https://stackoverflow.com/questions/46898/how-do-i-efficiently-iterate-over-each-entry-in-a-java-map


HashMap<String, HashMap> selects = new HashMap<String, HashMap>();

for(Map.Entry<String, HashMap> entry : selects.entrySet()) {
    String key = entry.getKey();
    HashMap value = entry.getValue();

    // do what you have to do here
    // In your case, another loop.
}   

/***************************************************************************************************************/
转换string 然后和string的一些操作方法.
String rst = new StringBuilder(Math.abs(num)+"").reverse().toString();
/***************************************************************************************************************/
% 操作，n % m n《 m直接返回n，大于m，返回余数


/***************************************************************************************************************/
打擂台基本操作。

public int smallestDifference(int[] A, int[] B) {
    if (A == null || A.length == 0 || B == null || B.length == 0) {
        return 0;
    }

    Arrays.sort(A);
    Arrays.sort(B);

    int ai = 0, bi = 0;
    int min = Integer.MAX_VALUE; //选最小值，一定要用MAX
    while (ai < A.length && bi < B.length) {
        min = Math.min(min, Math.abs(A[ai] - B[bi]));
        if (A[ai] < B[bi]) {
            ai++;
        } else {
            bi++;
        }
    }
        return min;
    }
/***************************************************************************************************************/
string.charAt(i) - '0' --> 就是int


/***************************************************************************************************************/
    ListNode find(ListNode bucket, int key) {
        ListNode node = bucket, prev = null;
        while (node != null && node.key != key) {
            prev = node;
            node = node.next;
        }
        return prev;
    }
    
    在linkedlist里面，是不是可以简单记忆prev = node; 等价于 prev-》node-》node.next

/***************************************************************************************************************/
nlogn 
logn是提示：heap，binary search，二叉树，归并，dc
关于string一些：
String[] val = data.substring(1, data.length() - 1).split(",");


基础知识 hashmap：

class Solution {
    public int firstUniqChar(String s) {
        HashMap<Character, Integer> count = new HashMap<Character, Integer>();
        int n = s.length();
        for(char c : s.toCharArray()){
            count.put(c, count.getOrDefault(c, 0) + 1);//要么get要么给defalut value
        }
        for(int i = 0; i < n; i++){
            if(count.get(s.charAt(i)) == 1){
                return i;
            }
        }
        return -1;
    }
}
https://www.lintcode.com/problem/first-unique-character-in-a-string/description

还可以扩展到data stream可怕。。。看一下


char[] charArray = s.toCharArray();
见到string第一个反应必须是这样
/***************************************************************************************************************/
XOR bit operation:
/***************************************************************************************************************/

char 要用''不要用""
class Solution {
    public boolean judgeCircle(String moves) {
        int x = 0, y = 0;
        for (char move: moves.toCharArray()) {
            if (move == 'U') y--;
            else if (move == 'D') y++;
            else if (move == 'L') x--;
            else if (move == 'R') x++;
        }
        return x == 0 && y == 0;
    }
}

/***************************************************************************************************************/
HashSet add, contains
/***************************************************************************************************************/

String[] s = paragraph.split("[!?',;. ]");
这个可以把包括空格之类的都能分开.
